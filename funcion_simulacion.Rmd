---
title: "Función simulacion"
author: "Daniel Escobar David"
date: "2/9/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message = F,warning = F)
```


```{r}
set.seed(1214747297)
library(geoR)
library (gstat)
library(MASS)
library(sf)
library(sp)
library(geoR)
library(raster)
library(ggplot2)
library(moments)
library(forecast)
library(rcompanion)
library(HDInterval)
```

# Definición Contorno
```{r}
cont_bzl <- shapefile("brazil_administrative_boundaries_national_polygon.shp")
cont <- cont_bzl@polygons[[2]]@Polygons[[1]]@coords

brazil_contorno <-SpatialPolygons(list(Polygons(list(Polygon( cont )), "x")))
brazil_contorno <- st_as_sf(brazil_contorno)
st_crs(brazil_contorno) = 4326
brazil_contorno <- st_transform(brazil_contorno,29101)
contorno <- st_coordinates(brazil_contorno)[,c(1,2)]
```

# Datos reales transformados

```{r}
#-----------------------------------------------------------#
# DATOS REALES PARA PARA LA SIMULACION GAUSSIANA SEQUENCIAL #
#-----------------------------------------------------------#
load("viento.RData") # Datos reales
viento$Value <- as.numeric(viento$Value)
viento <- na.omit(viento)

brazil_espacial <- st_as_sf(viento[,-1],coords = c("Longitude","Latitude"), crs = 4326, agr = "constant")
brazil_espacial$Value <- as.numeric(brazil_espacial$Value) # Datos en formato sf
brazil_espacial <- st_transform(brazil_espacial,29101) # Datos a coordenadas plana
#-----------------------------------------------------------#
# TRANFORMAR DATOS REALES PARA QUE SE DISTRIBUYAN NORMAL    #
#-----------------------------------------------------------#
datos <- cbind("viento"=brazil_espacial$Value,st_coordinates(brazil_espacial)[,c(1,2)])
datos <- na.omit(datos)
datos <- as.data.frame(datos)
#
test <- na.omit(datos$viento)
P <- ecdf(test) # función de distribución acumulada
datos_t <- blom(test) # Datos con Transformación Normal Scores
datos_t <- cbind(datos[,c(2,3)],datos_t) # Datos transformados con coordenadas
names(datos_t)[3] <-"Value"
brazil_espacial_t <- st_as_sf(datos_t,coords = c("X","Y"), crs = 29101, agr = "constant")
#----------------------------------------------#
# DATOS TRANSFORADOS CON COORDENADAS SEPARADAS #
#----------------------------------------------#
datos_tt <- cbind("viento"=brazil_espacial_t$Value,st_coordinates(brazil_espacial_t)[,c(1,2)])
datos_tt <- as.data.frame(datos_tt)
coordinates(datos_tt) <- ~X+Y
#---------------------------------------#
# AJUSTE VARIOGRAMA DATOS TRANSFORMADOS #
#---------------------------------------#
vbin <- variogram(viento ~ 1, locations = coordinates(datos_tt),datos_tt)
vbin.fit <- fit.variogram(vbin,vgm(c("Gau", "Sph", "Mat", "Exp")), fit.kappa = TRUE)
```

# Funcion para generar valores en las n ubicaciones

```{r}
OK_IDW_n_values <- function(n,contorno,datos_t,datos_tt,vbin.fit){
#------------------------#
# GENERACION DE N PUNTOS #
#------------------------#
n <- n
u1 <- runif(1,2795398,7142564)
u2 <- runif(1,6250620,10586132)
grid <- cbind(u1,u2)
in_sim <- matrix(grid[.geoR_inout(grid, contorno),],ncol=2)

if(all(is.na(in_sim)==T)){
  grid <- grid[-1,]
}

# DADO UN n: NUMERO DE PUNTOS A SIMULAR
while(dim(grid)[1]<n | all(is.na(grid)==T)){
  row_in_sim <-dim(grid)[1] # Datos actuales en el contorno
  u1 <- runif(1,2795398,7142564)
  u2 <- runif(1,6250620,10586132)
  new <- cbind(u1,u2)
  
  grid <- rbind(grid,new)
  in_sim <- matrix(grid[.geoR_inout(grid, contorno),],ncol=2) # Esta dentro del contorno?
  
  if(dim(in_sim)[1]<=row_in_sim){ # Aumento el numero de puntos en el contorno?
  grid <- matrix(grid[-dim(grid)[1],],ncol=2)
}
  
}

#---------------------------------#
# SIMULACION GAUSSIANA SEQUENCIAL #
#---------------------------------#
mu_sigma <- matrix(0,nrow = n,ncol=2)# Matriz mu-sigma para cada ubicación 
colnames(mu_sigma) <- c("mu","sigma")# Para guardar mu y sigma de kriging
#----------------------------------------------------------------------------
#----------------------------------------------------------------------------
for (i in 1:n) {
  #-------------------------------------------------------
  # Kriging con la muestra para obtener mu y sigma
  #-------------------------------------------------------
  
  if(i==1){
    datos_pred.grid <- matrix(grid[c(i:2),],ncol=2 )# Ubicaciones simuladas
  }else{datos_pred.grid <- matrix(grid[c(i:(i-1)),],ncol=2 )}# Ubicaciones simuladas
  
  colnames(datos_pred.grid) <- c("X","Y")
  coords_pred <- as.data.frame(coordinates(datos_pred.grid))
  gridded(coords_pred) = ~X+Y
  
  a <- capture.output(ubi.kriged <-  krige(viento~1,datos_tt,coords_pred[1,], model = vbin.fit)) # Predicción Krige
  mu <- as.numeric(ubi.kriged["var1.pred"]@data)
  sigma <- as.numeric(ubi.kriged["var1.var"]@data)
  mu_sigma[i,] <- c(mu,sigma) # Valores mu y sigma para generar valor en la ubicacion "i"
  #----------------------------------------------------------------------------
  #----------------------------------------------------------------------------
  #-------------------------------------------------------
  # Nuevo valor generado
  #-------------------------------------------------------
  z <- rnorm(1,mu,sigma)
  new <- matrix(c(grid[i,],z),ncol=3)
  colnames(new) <- c("X","Y","Value")
  #----------------------------------------------------------------------------
  #----------------------------------------------------------------------------
  #-------------------------------------------------------
  # Agregar nuevo valor a la muestra
  #-------------------------------------------------------
  datos_t <- rbind(datos_t,new) # Datos transformados con coordenadas
  names(datos_t)[3] <-"Value"
  # Poner datos en formato correcto
  brazil_espacial_t <- st_as_sf(datos_t,coords = c("X","Y"), crs = 29101, agr = "constant")
  datos_tt <- cbind("viento"=brazil_espacial_t$Value,st_coordinates(brazil_espacial_t)[,c(1,2)])
  datos_tt <- as.data.frame(datos_tt)
  coordinates(datos_tt) <- ~X+Y
  # Ajustar variograma
  vbin <- variogram(viento ~ 1, locations = coordinates(datos_tt),datos_tt)
  # Fit Bin
  vbin.fit <- fit.variogram(vbin,vgm(c("Gau", "Sph", "Mat", "Exp")), fit.kappa = TRUE)
}

return(mu_sigma)

}
```

# Funcion para replicar valores en las n ubicaciones

```{r}
#--------------------#
# DATOS PARA VALIDAR #
#--------------------#
index_test <- sample(1:nrow(datos),.3*nrow(datos)) # Indice muestra de prueba
  ubi_test <- datos_t[index_test,c(1,2)]
  real <- datos[index_test,1]
```

```{r}
#-----------------------#
# FUNCION PARA REPLCIAR #
#-----------------------#
mse_ok_idw <- function(mu_sigma){
  # valores : valores simulados (values_sim)
  # malla: ubicaciones simuladas (grid)
  # data: datos reales (datos)
  # cont: contorno (contorno)
  # P: cdf datos reales

  valores_sim <- rnorm(dim(grid)[1],mu_sigma[,1],mu_sigma[,2])
  
  grid_s <- data.frame(cbind(grid,valores_sim)) # Datos simulados (grid simulada)
  colnames(grid_s)<-c("X","Y","viento")
  #-------------------------------------------------
  #coordinates(grid_s) <- ~X+Y
  #--------------------------------
  #-------------------------------------------------
  # Ajuste semi-variograma 
  vbin_sim <- variogram(viento ~ X+Y, locations = ~X+Y,grid_s)

  # Fit Bin
  vbin.fit_sim <- fit.variogram(vbin_sim,vgm(c("Gau", "Sph", "Mat", "Exp")), fit.kappa = TRUE)
  #-------------------------
  # Prediccion Kriging e IDW ubicaciones de prueba
  values_predsim <- numeric(length(index_test)) # Vector de valores simulados OK
  values_predsim_idw <- numeric(length(index_test)) # Vector de valores simulados IDW
  for (i in 1:length(index_test)) {
  if(i==1){
    datos_pred.grid <- ubi_test[c(i:2),]# Ubicaciones simuladas
  }else{datos_pred.grid <- ubi_test[c(i:(i-1)),]}# Ubicaciones simuladas
  colnames(datos_pred.grid) <- c("X","Y")
  coords_pred <- as.data.frame(coordinates(datos_pred.grid))
  gridded(coords_pred) = ~X+Y
  
  c <- capture.output(ubi.kriged <-krige(viento~X+Y,grid_s,coords_pred[1,], model = vbin.fit_sim)) # Predicción Krige
  d <-capture.output(ubi_idw <-gstat::idw(viento~1,grid_s,coords_pred[1,])) # Prediccion idw
  
  mu_k <- as.numeric(ubi.kriged["var1.pred"]@data)
  mu_idw <- as.numeric(ubi_idw["var1.pred"]@data)

  values_predsim[i] <- mu_k
  values_predsim_idw[i] <- mu_idw
  }
  t_values_predsim <- inverseCDF(pnorm(values_predsim),P) # Valores pred tranformados Krig
  t_values_predsim_idw <- inverseCDF(pnorm(values_predsim_idw),P) # Valores pred tranformados idw

  MSE_OK <- mean((t_values_predsim-real)^2)
  MSE_IDW <- mean((t_values_predsim_idw-real)^2)
   
  c(MSE_OK,MSE_IDW)
}
```


```{r}
library(future.apply)
plan(multisession, workers = 8)
n <- 50
n_sim <- OK_IDW_n_values(n,contorno,datos_t,datos_tt,vbin.fit)

g <- future_replicate(100, expr = mse_ok_idw(mu_sigman_sim))
```

